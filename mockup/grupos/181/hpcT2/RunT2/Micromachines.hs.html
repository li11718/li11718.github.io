<html>
<head><!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-108230466-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-108230466-1');
</script>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body><pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>module Micromachines where
<span class="lineno">    2 </span>
<span class="lineno">    3 </span>import Data.Maybe
<span class="lineno">    4 </span>import Data.List
<span class="lineno">    5 </span>
<span class="lineno">    6 </span>import LI11718
<span class="lineno">    7 </span>
<span class="lineno">    8 </span>import MicromachinesTestes
<span class="lineno">    9 </span>
<span class="lineno">   10 </span>-- import Debug.Trace
<span class="lineno">   11 </span>
<span class="lineno">   12 </span>--------------
<span class="lineno">   13 </span>-- == T1: Constroi Mapa
<span class="lineno">   14 </span>--------------
<span class="lineno">   15 </span>
<span class="lineno">   16 </span>-- | Dado um caminho qualquer, constroi o mapa associado
<span class="lineno">   17 </span>constroi :: Caminho -&gt; Mapa
<span class="lineno">   18 </span><span class="decl"><span class="nottickedoff">constroi c = let p = partida c</span>
<span class="lineno">   19 </span><span class="spaces">                 </span><span class="nottickedoff">o = dirInit</span>
<span class="lineno">   20 </span><span class="spaces">                 </span><span class="nottickedoff">h = altInit</span>
<span class="lineno">   21 </span><span class="spaces">                 </span><span class="nottickedoff">d = dimensao c</span>
<span class="lineno">   22 </span><span class="spaces">             </span><span class="nottickedoff">in Mapa (p,o) $ caminho2mapa d p o h c</span></span>
<span class="lineno">   23 </span>
<span class="lineno">   24 </span>-- size, posicao actual, orientacao actuao, altura actual
<span class="lineno">   25 </span>caminho2mapa :: Posicao -&gt; Posicao -&gt; Orientacao -&gt; Altura -&gt; Caminho -&gt; Tabuleiro
<span class="lineno">   26 </span><span class="decl"><span class="nottickedoff">caminho2mapa d _ _ _ [] = mapaLava d</span>
<span class="lineno">   27 </span><span class="spaces"></span><span class="nottickedoff">caminho2mapa d p o h (CurvaEsq:cs) =</span>
<span class="lineno">   28 </span><span class="spaces">  </span><span class="nottickedoff">let m = caminho2mapa d (proxPos p $ rodaEsq o) (rodaEsq o) h cs</span>
<span class="lineno">   29 </span><span class="spaces">  </span><span class="nottickedoff">in if isLava (getPeca p m) then setPeca p (Peca (Curva $ rodaDir o) h) m else m</span>
<span class="lineno">   30 </span><span class="spaces"></span><span class="nottickedoff">caminho2mapa d p o h (CurvaDir:cs) =</span>
<span class="lineno">   31 </span><span class="spaces">  </span><span class="nottickedoff">let m = caminho2mapa d (proxPos p $ rodaDir o) (rodaDir o) h cs</span>
<span class="lineno">   32 </span><span class="spaces">  </span><span class="nottickedoff">in if isLava (getPeca p m) then setPeca p (Peca (Curva o) h) m else m</span>
<span class="lineno">   33 </span><span class="spaces"></span><span class="nottickedoff">caminho2mapa d p o h (Sobe:cs) =</span>
<span class="lineno">   34 </span><span class="spaces">  </span><span class="nottickedoff">let m = caminho2mapa d (proxPos p o) o (h+1) cs</span>
<span class="lineno">   35 </span><span class="spaces">  </span><span class="nottickedoff">in if isLava (getPeca p m) then setPeca p (Peca (Rampa o) h) m else m</span>
<span class="lineno">   36 </span><span class="spaces"></span><span class="nottickedoff">caminho2mapa d p o h (Desce:cs) =</span>
<span class="lineno">   37 </span><span class="spaces">  </span><span class="nottickedoff">let m = caminho2mapa d (proxPos p o) o (h-1) cs</span>
<span class="lineno">   38 </span><span class="spaces">  </span><span class="nottickedoff">in if isLava (getPeca p m) then setPeca p (Peca (Rampa $ inverte o) (h-1)) m else m</span>
<span class="lineno">   39 </span><span class="spaces"></span><span class="nottickedoff">caminho2mapa d p o h (Avanca:cs) =</span>
<span class="lineno">   40 </span><span class="spaces">  </span><span class="nottickedoff">let m = caminho2mapa d (proxPos p o) o h cs</span>
<span class="lineno">   41 </span><span class="spaces">  </span><span class="nottickedoff">in if isLava (getPeca p m) then setPeca p (Peca Recta h) m else m</span></span>
<span class="lineno">   42 </span>
<span class="lineno">   43 </span>-- Assumindo que o eixo vertical cresce de cima para baixo
<span class="lineno">   44 </span>-- dimensao :: Caminho -&gt; Dimensao
<span class="lineno">   45 </span>-- dimensao c =
<span class="lineno">   46 </span>--   let ((xmin,ymin),(xmax,ymax)) = fronteira c (0,0) dirInit
<span class="lineno">   47 </span>--   in (xmax + (abs xmin)+3, ymax + (abs ymin)+3)
<span class="lineno">   48 </span>
<span class="lineno">   49 </span>-- partida :: Caminho -&gt; Posicao
<span class="lineno">   50 </span>-- partida c = let ((xmin,ymin),_) = fronteira c (0,0) dirInit
<span class="lineno">   51 </span>--             in (abs xmin + 1, abs ymin + 1)
<span class="lineno">   52 </span>
<span class="lineno">   53 </span>-- fronteira :: Caminho -&gt; Posicao -&gt; Orientacao -&gt; (Posicao,Posicao)
<span class="lineno">   54 </span>-- fronteira []            p _ = (p,p)
<span class="lineno">   55 </span>-- fronteira (CurvaEsq:cs) p o =
<span class="lineno">   56 </span>--   minMax p $ fronteira cs (proxPos p (rodaEsq o)) (rodaEsq o)
<span class="lineno">   57 </span>-- fronteira (CurvaDir:cs) p o =
<span class="lineno">   58 </span>--   minMax p $ fronteira cs (proxPos p (rodaDir o)) (rodaDir o)
<span class="lineno">   59 </span>-- fronteira (_:cs)        p o =
<span class="lineno">   60 </span>--   minMax p $ fronteira cs (proxPos p o) o
<span class="lineno">   61 </span>
<span class="lineno">   62 </span>--------------
<span class="lineno">   63 </span>-- == T2: Mapa válido
<span class="lineno">   64 </span>--------------
<span class="lineno">   65 </span>
<span class="lineno">   66 </span>-- | Verifica se um dado mapa é válido:
<span class="lineno">   67 </span>--
<span class="lineno">   68 </span>--    * começando da partida volta-se a chegar à partida
<span class="lineno">   69 </span>--    * não há peças de caminho não utilizadas
<span class="lineno">   70 </span>--    * peças só podem estar ligadas por lados com a mesma altura
<span class="lineno">   71 </span>validaMapa :: Mapa -&gt; Bool
<span class="lineno">   72 </span><span class="decl"><span class="nottickedoff">validaMapa mp@(Mapa (p,o) m) = restoComLava m $ posicoesDoCaminho mp</span></span>
<span class="lineno">   73 </span>
<span class="lineno">   74 </span>posicoesDoCaminho :: Mapa -&gt; Maybe [Posicao]
<span class="lineno">   75 </span><span class="decl"><span class="nottickedoff">posicoesDoCaminho mapa@(Mapa (pt,ot) m) =</span>
<span class="lineno">   76 </span><span class="spaces">  </span><span class="nottickedoff">if not (inBounds pt bounds) || not (linhasMesmoTamanho m) || isLava (getPeca pt m) || not (voltaEmLava m)</span>
<span class="lineno">   77 </span><span class="spaces">  </span><span class="nottickedoff">then Nothing else percorre (proxByPeca (getPeca pt m) ot pt) m</span>
<span class="lineno">   78 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">   79 </span><span class="spaces">    </span><span class="nottickedoff">bounds :: Posicao</span>
<span class="lineno">   80 </span><span class="spaces">    </span><span class="nottickedoff">bounds = sizeMapa mapa</span>
<span class="lineno">   81 </span><span class="spaces">    </span><span class="nottickedoff"></span>
<span class="lineno">   82 </span><span class="spaces">    </span><span class="nottickedoff">percorre :: (Posicao,Orientacao,Altura) -&gt; Tabuleiro -&gt; Maybe [Posicao]</span>
<span class="lineno">   83 </span><span class="spaces">    </span><span class="nottickedoff">percorre (p,o,h) m | not (inBounds p bounds) = Nothing</span>
<span class="lineno">   84 </span><span class="spaces">    </span><span class="nottickedoff">percorre (p,o,h) m = let pc = getPeca p m</span>
<span class="lineno">   85 </span><span class="spaces">                         </span><span class="nottickedoff">in if acessoOk o pc h then</span>
<span class="lineno">   86 </span><span class="spaces">                              </span><span class="nottickedoff">if pt == p &amp;&amp; ot == o then Just [p]</span>
<span class="lineno">   87 </span><span class="spaces">                              </span><span class="nottickedoff">else if pt == p &amp;&amp; isCurva pc then Nothing</span>
<span class="lineno">   88 </span><span class="spaces">                                   </span><span class="nottickedoff">else percorre (proxByPeca pc o p) m &gt;&gt;= (Just.((:) p))</span>
<span class="lineno">   89 </span><span class="spaces">                            </span><span class="nottickedoff">else Nothing</span></span>
<span class="lineno">   90 </span>
<span class="lineno">   91 </span>restoComLava :: Tabuleiro -&gt; Maybe [Posicao] -&gt; Bool
<span class="lineno">   92 </span><span class="decl"><span class="nottickedoff">restoComLava _ Nothing   = False</span>
<span class="lineno">   93 </span><span class="spaces"></span><span class="nottickedoff">restoComLava _ (Just []) = False</span>
<span class="lineno">   94 </span><span class="spaces"></span><span class="nottickedoff">restoComLava m (Just ps) = sort (filtraPeca m (not . lava)) == (sort.nub) ps</span>
<span class="lineno">   95 </span><span class="spaces">  </span><span class="nottickedoff">where lava :: Peca -&gt; Bool</span>
<span class="lineno">   96 </span><span class="spaces">        </span><span class="nottickedoff">lava (Peca Lava h) = h == altLava</span>
<span class="lineno">   97 </span><span class="spaces">        </span><span class="nottickedoff">lava _             = False</span></span>
<span class="lineno">   98 </span>
<span class="lineno">   99 </span>voltaEmLava :: Tabuleiro -&gt; Bool
<span class="lineno">  100 </span><span class="decl"><span class="nottickedoff">voltaEmLava t = foldr (\p a -&gt; isLava p &amp;&amp; a) True (head t)</span>
<span class="lineno">  101 </span><span class="spaces">                </span><span class="nottickedoff">&amp;&amp; foldr (\p a -&gt; isLava p &amp;&amp; a) True (last t)</span>
<span class="lineno">  102 </span><span class="spaces">                </span><span class="nottickedoff">&amp;&amp; foldr (\l a -&gt; isLava (head l) &amp;&amp; isLava (last l) &amp;&amp; a) True t</span></span>
<span class="lineno">  103 </span>
<span class="lineno">  104 </span>-- --------------
<span class="lineno">  105 </span>-- == T3: Colisões
<span class="lineno">  106 </span>-- --------------
<span class="lineno">  107 </span>
<span class="lineno">  108 </span>-- | Dado um ponto e uma velocidade inciais, e uma duração de tempo, se houver 
<span class="lineno">  109 </span>--   uma colisão ou uma queda, calcula um ponto de chegada e a nova velocidade 
<span class="lineno">  110 </span>--   assumindo que:
<span class="lineno">  111 </span>--
<span class="lineno">  112 </span>--   * a velocidade se mantem constante;
<span class="lineno">  113 </span>--   * se bater numa parede a velocidade é reflectida e a sua norma é mantida
<span class="lineno">  114 </span>--   * se cair ou passar pela lava, a velocidade final é nula e a posição final
<span class="lineno">  115 </span>--     é o centro da peça onde caíu ou atravessou para a lava.
<span class="lineno">  116 </span>--   * caso contrário (não há colisões nem quedas) devolve Nothing 
<span class="lineno">  117 </span>colide :: Tabuleiro -&gt; Tempo -&gt; Carro -&gt; Maybe Carro
<span class="lineno">  118 </span><span class="decl"><span class="nottickedoff">colide m t c = undefined</span></span>
<span class="lineno">  119 </span>  --let (Peca _ h) = getPeca (ponto2pos $ posicao c) m
<span class="lineno">  120 </span>  --             in aux m t c h
<span class="lineno">  121 </span>
<span class="lineno">  122 </span>-- aux :: Tabuleiro -&gt; Tempo -&gt; Carro -&gt; Altura -&gt; Maybe Carro
<span class="lineno">  123 </span>-- aux m t c h =
<span class="lineno">  124 </span>--   if not (inTabuleiro p m) || isLava pc || hpc &lt; h then Nothing else
<span class="lineno">  125 </span>--   case colideDentro pc p f of
<span class="lineno">  126 </span>--     (Just cp) -&gt; colidiu no ponto cp
<span class="lineno">  127 </span>--     Nothing -&gt; 
<span class="lineno">  128 </span>--   where
<span class="lineno">  129 </span>--     pos = posicao c
<span class="lineno">  130 </span>--     p = ponto2pos pos
<span class="lineno">  131 </span>--     f = final p (velocidade c) t
<span class="lineno">  132 </span>--     pc@(Peca tpc hpc) = getPeca p m
<span class="lineno">  133 </span>
<span class="lineno">  134 </span>low, high :: Double -&gt; Double
<span class="lineno">  135 </span><span class="decl"><span class="nottickedoff">low d = toEnum $ floor d</span></span>
<span class="lineno">  136 </span><span class="decl"><span class="nottickedoff">high d = toEnum $ ceiling $ d + 0.00000000000001</span></span> -- martelada para funcionar nas
<span class="lineno">  137 </span>                                                 -- linhas/colunas, pontos do tipo _.0000
<span class="lineno">  138 </span>
<span class="lineno">  139 </span>parede :: Peca -&gt; Ponto -&gt; Altura -&gt; Bool
<span class="lineno">  140 </span><span class="decl"><span class="nottickedoff">parede (Peca Recta hpc) _ h = h &lt; hpc</span></span>
<span class="lineno">  141 </span>
<span class="lineno">  142 </span>{- | Recebe uma peca, um ponto inicial e um ponto final. Calcula
<span class="lineno">  143 </span> a primeira intersecção com uma linha.
<span class="lineno">  144 </span>
<span class="lineno">  145 </span>  __Assume que está numa posição válida, ou seja, numa posição de estrada.__
<span class="lineno">  146 </span>
<span class="lineno">  147 </span>-}
<span class="lineno">  148 </span>transita :: Peca -&gt; Ponto -&gt; Ponto -&gt; Ponto
<span class="lineno">  149 </span><span class="decl"><span class="nottickedoff">transita pc p f = case colideDentro pc p f of</span>
<span class="lineno">  150 </span><span class="spaces">  </span><span class="nottickedoff">Nothing  -&gt; transitaAresta p f</span>
<span class="lineno">  151 </span><span class="spaces">  </span><span class="nottickedoff">(Just p) -&gt; p</span></span>
<span class="lineno">  152 </span>
<span class="lineno">  153 </span>-- | Devolve a próxima aresta no caminho
<span class="lineno">  154 </span>transitaAresta :: Ponto -&gt; Ponto -&gt; Ponto
<span class="lineno">  155 </span><span class="decl"><span class="nottickedoff">transitaAresta p@(x,y) f@(fx,fy) =</span>
<span class="lineno">  156 </span><span class="spaces">  </span><span class="nottickedoff">let mx = if fx - x &gt; 0 then high x else low x</span>
<span class="lineno">  157 </span><span class="spaces">      </span><span class="nottickedoff">my = if fy - y &gt; 0 then high y else low y</span>
<span class="lineno">  158 </span><span class="spaces">      </span><span class="nottickedoff">interseccaoV = intersecta ((mx,low y),(mx, high y)) (p,f)</span>
<span class="lineno">  159 </span><span class="spaces">      </span><span class="nottickedoff">interseccaoH = intersecta ((low x,my),(high x, my)) (p,f)</span>
<span class="lineno">  160 </span><span class="spaces">  </span><span class="nottickedoff">in case (interseccaoV,interseccaoH) of</span>
<span class="lineno">  161 </span><span class="spaces">       </span><span class="nottickedoff">(Nothing, Nothing) -&gt; f</span>
<span class="lineno">  162 </span><span class="spaces">       </span><span class="nottickedoff">(Just p, Nothing)  -&gt; p</span>
<span class="lineno">  163 </span><span class="spaces">       </span><span class="nottickedoff">(Nothing, Just p)  -&gt; p</span>
<span class="lineno">  164 </span><span class="spaces">       </span><span class="nottickedoff">(Just p1, Just p2) -&gt; p1</span></span>
<span class="lineno">  165 </span>
<span class="lineno">  166 </span>colideDentro :: Peca -&gt; Ponto -&gt; Ponto -&gt; Maybe Ponto
<span class="lineno">  167 </span><span class="decl"><span class="nottickedoff">colideDentro pc p f =</span>
<span class="lineno">  168 </span><span class="spaces">  </span><span class="nottickedoff">case interNaPeca pc (ponto2pos p) of</span>
<span class="lineno">  169 </span><span class="spaces">    </span><span class="nottickedoff">Nothing  -&gt; Nothing</span>
<span class="lineno">  170 </span><span class="spaces">    </span><span class="nottickedoff">(Just i) -&gt; intersecta i (p,f)</span></span>
<span class="lineno">  171 </span>
<span class="lineno">  172 </span>interNaPeca :: Peca -&gt; Posicao -&gt; Maybe Linha
<span class="lineno">  173 </span><span class="decl"><span class="nottickedoff">interNaPeca (Peca Recta _)          _    = Nothing</span>
<span class="lineno">  174 </span><span class="spaces"></span><span class="nottickedoff">interNaPeca (Peca (Rampa _) _)      _    = Nothing</span>
<span class="lineno">  175 </span><span class="spaces"></span><span class="nottickedoff">interNaPeca (Peca (Curva Norte) _) (x,y) = Just (pos2ponto (x+1,y),pos2ponto (x,y+1))</span>
<span class="lineno">  176 </span><span class="spaces"></span><span class="nottickedoff">interNaPeca (Peca (Curva Sul) _)   (x,y) = Just (pos2ponto (x+1,y),pos2ponto (x,y+1))</span>
<span class="lineno">  177 </span><span class="spaces"></span><span class="nottickedoff">interNaPeca (Peca (Curva Este) _)  (x,y) = Just (pos2ponto (x,y),pos2ponto (x+1,y+1))</span>
<span class="lineno">  178 </span><span class="spaces"></span><span class="nottickedoff">interNaPeca (Peca (Curva Oeste) _) (x,y) = Just (pos2ponto (x,y),pos2ponto (x+1,y+1))</span></span>
<span class="lineno">  179 </span>  
<span class="lineno">  180 </span>-- EXEMPLO
<span class="lineno">  181 </span><span class="decl"><span class="nottickedoff">p = (1.1,2.1)</span></span>
<span class="lineno">  182 </span><span class="decl"><span class="nottickedoff">v = (1,-1)</span></span>
<span class="lineno">  183 </span><span class="decl"><span class="nottickedoff">t = 1</span></span>
<span class="lineno">  184 </span><span class="decl"><span class="nottickedoff">f = final p v t</span></span>
<span class="lineno">  185 </span>--(lv,lh) = linhas (p,f)
<span class="lineno">  186 </span>
<span class="lineno">  187 </span>type Linha = (Ponto,Ponto)
<span class="lineno">  188 </span>
<span class="lineno">  189 </span>{- | Calcula o ponto de intercepção entre duas linhas -}
<span class="lineno">  190 </span>-- copiado do Gloss para Double
<span class="lineno">  191 </span>intersecta :: Linha -&gt; Linha -&gt; Maybe Ponto
<span class="lineno">  192 </span><span class="decl"><span class="nottickedoff">intersecta (p1,p2) (p3,p4) | Just p0 &lt;- intersectaL p1 p2 p3 p4</span>
<span class="lineno">  193 </span><span class="spaces">                           </span><span class="nottickedoff">, t12   &lt;- closestPontoOnL p1 p2 p0</span>
<span class="lineno">  194 </span><span class="spaces">                           </span><span class="nottickedoff">, t23   &lt;- closestPontoOnL p3 p4 p0</span>
<span class="lineno">  195 </span><span class="spaces">                           </span><span class="nottickedoff">, t12 &gt;= 0 &amp;&amp; t12 &lt;= 1</span>
<span class="lineno">  196 </span><span class="spaces">                           </span><span class="nottickedoff">, t23 &gt;= 0 &amp;&amp; t23 &lt;= 1</span>
<span class="lineno">  197 </span><span class="spaces">                           </span><span class="nottickedoff">= Just p0</span>
<span class="lineno">  198 </span><span class="spaces">                           </span><span class="nottickedoff">| otherwise</span>
<span class="lineno">  199 </span><span class="spaces">                           </span><span class="nottickedoff">= Nothing</span></span>
<span class="lineno">  200 </span>
<span class="lineno">  201 </span>-- copiado do Gloss para Double
<span class="lineno">  202 </span>intersectaL :: Ponto -&gt; Ponto -&gt; Ponto -&gt; Ponto -&gt; Maybe Ponto
<span class="lineno">  203 </span><span class="decl"><span class="nottickedoff">intersectaL (x1, y1) (x2, y2) (x3, y3) (x4, y4)</span>
<span class="lineno">  204 </span><span class="spaces"> </span><span class="nottickedoff">= let  dx12  = x1 - x2</span>
<span class="lineno">  205 </span><span class="spaces">        </span><span class="nottickedoff">dx34  = x3 - x4</span>
<span class="lineno">  206 </span><span class="spaces">        </span><span class="nottickedoff">dy12  = y1 - y2</span>
<span class="lineno">  207 </span><span class="spaces">        </span><span class="nottickedoff">dy34  = y3 - y4</span>
<span class="lineno">  208 </span><span class="spaces">  </span><span class="nottickedoff"></span>
<span class="lineno">  209 </span><span class="spaces">        </span><span class="nottickedoff">den = dx12 * dy34  - dy12 * dx34</span>
<span class="lineno">  210 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  211 </span><span class="spaces">    </span><span class="nottickedoff">in if den == 0</span>
<span class="lineno">  212 </span><span class="spaces">       </span><span class="nottickedoff">then Nothing</span>
<span class="lineno">  213 </span><span class="spaces">       </span><span class="nottickedoff">else let det12 = x1*y2 - y1*x2 </span>
<span class="lineno">  214 </span><span class="spaces">                </span><span class="nottickedoff">det34 = x3*y4 - y3*x4 </span>
<span class="lineno">  215 </span><span class="spaces">                </span><span class="nottickedoff">numx  = det12 * dx34 - dx12 * det34</span>
<span class="lineno">  216 </span><span class="spaces">                </span><span class="nottickedoff">numy  = det12 * dy34 - dy12 * det34</span>
<span class="lineno">  217 </span><span class="spaces">            </span><span class="nottickedoff">in Just (numx / den, numy / den)</span></span>
<span class="lineno">  218 </span>
<span class="lineno">  219 </span>-- copiado do Gloss para Double
<span class="lineno">  220 </span>closestPontoOnL :: Ponto -&gt; Ponto -&gt; Ponto -&gt; Double
<span class="lineno">  221 </span><span class="decl"><span class="nottickedoff">closestPontoOnL p1 p2 p3 = (p3 .-. p1) .$. (p2 .-. p1) / (p2 .-. p1) .$. (p2 .-. p1)</span>
<span class="lineno">  222 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  223 </span><span class="spaces">    </span><span class="nottickedoff">(.*.) :: Double -&gt; (Double,Double) -&gt; (Double,Double)</span>
<span class="lineno">  224 </span><span class="spaces">    </span><span class="nottickedoff">(.*.) x (a,b) = ((x*a),(x*b))</span>
<span class="lineno">  225 </span><span class="spaces">                    </span><span class="nottickedoff"></span>
<span class="lineno">  226 </span><span class="spaces">    </span><span class="nottickedoff">(.+.) :: (Double,Double) -&gt; (Double,Double) -&gt; (Double,Double)</span>
<span class="lineno">  227 </span><span class="spaces">    </span><span class="nottickedoff">(.+.) (x,y) (a,b) = ((x+a),(y+b))</span>
<span class="lineno">  228 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  229 </span><span class="spaces">    </span><span class="nottickedoff">(.-.) :: (Double,Double) -&gt; (Double,Double) -&gt; (Double,Double)</span>
<span class="lineno">  230 </span><span class="spaces">    </span><span class="nottickedoff">(.-.) (x,y) (a,b) = ((x-a),(y-b))</span>
<span class="lineno">  231 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  232 </span><span class="spaces">    </span><span class="nottickedoff">-- the dot product between two (Double,Double)s</span>
<span class="lineno">  233 </span><span class="spaces">    </span><span class="nottickedoff">(.$.) :: (Double,Double) -&gt; (Double,Double) -&gt; Double</span>
<span class="lineno">  234 </span><span class="spaces">    </span><span class="nottickedoff">(.$.) (d1,a1) (d2,a2) = (x1*x2) + (y1*y2)</span>
<span class="lineno">  235 </span><span class="spaces">      </span><span class="nottickedoff">where (x1,y1) = (d1,a1)</span>
<span class="lineno">  236 </span><span class="spaces">            </span><span class="nottickedoff">(x2,y2) = (d2,a2)</span></span>
<span class="lineno">  237 </span>
<span class="lineno">  238 </span>
<span class="lineno">  239 </span>ponto2pos :: Ponto -&gt; Posicao
<span class="lineno">  240 </span><span class="decl"><span class="nottickedoff">ponto2pos (x,y) = (floor x, floor y)</span></span>
<span class="lineno">  241 </span>
<span class="lineno">  242 </span>pos2ponto :: Posicao -&gt; Ponto
<span class="lineno">  243 </span><span class="decl"><span class="nottickedoff">pos2ponto (x,y) = (toEnum x, toEnum y)</span></span>
<span class="lineno">  244 </span>
<span class="lineno">  245 </span>-- | Dado um ponto, um vector velocidade e um intervalo de tempo,
<span class="lineno">  246 </span>-- devolve o ponto final
<span class="lineno">  247 </span>final :: Ponto -&gt; Velocidade -&gt; Tempo -&gt; Ponto
<span class="lineno">  248 </span><span class="decl"><span class="nottickedoff">final p (vx,vy) t = (vx * t,vy * t) /+ p</span></span>
<span class="lineno">  249 </span>
<span class="lineno">  250 </span>(/+), (/-), (/*), (//)  :: Ponto -&gt; Ponto -&gt; Ponto
<span class="lineno">  251 </span><span class="decl"><span class="nottickedoff">(/+) (x1,y1) (x2,y2) = (x1 + x2, y1 + y2)</span></span>
<span class="lineno">  252 </span><span class="decl"><span class="nottickedoff">(/-) (x1,y1) (x2,y2) = (x1 - x2, y1 - y2)</span></span>
<span class="lineno">  253 </span><span class="decl"><span class="nottickedoff">(/*) (x1,y1) (x2,y2) = (x1 * x2, y1 * y2)</span></span>
<span class="lineno">  254 </span><span class="decl"><span class="nottickedoff">(//) (x1,y1) (x2,y2) = (x1 / x2, y1 / y2)</span></span>
<span class="lineno">  255 </span>
<span class="lineno">  256 </span>-- posicoes :: ([Ponto],[Ponto]) -&gt; [Posicao]
<span class="lineno">  257 </span>-- posicoes (v,h) =
<span class="lineno">  258 </span>--   let aux = foldr (\(x,y) a -&gt; (floor x, floor y) : (floor x - 1, floor y) : a) [] v
<span class="lineno">  259 </span>--   in nub $ foldr (\(x,y) a -&gt; (floor x, floor y) : (floor x, floor y - 1) : a) aux h
<span class="lineno">  260 </span>
<span class="lineno">  261 </span>-- -- | Devolve todas as posições entre no rectanculo @(x1,y1)@ e @(x2,y2)@
<span class="lineno">  262 </span>-- posicoesLinha :: Linha -&gt; [Posicao]
<span class="lineno">  263 </span>-- posicoesLinha (p1,p2) =
<span class="lineno">  264 </span>--   let ((x1,y1),(x2,y2)) = (ponto2pos p1, ponto2pos p2)
<span class="lineno">  265 </span>--   in [(x,y) | x &lt;- [x1..x2], y &lt;- [y1..y2]]
<span class="lineno">  266 </span>
<span class="lineno">  267 </span>
<span class="lineno">  268 </span>-- -- | Calcula todas as linhas (verticais e horizontais) entre dois pontos
<span class="lineno">  269 </span>-- linhas :: Linha -&gt; ([Linha],[Linha])
<span class="lineno">  270 </span>-- linhas ((x1,y1),(x2,y2)) =
<span class="lineno">  271 </span>--   let (mx1,mx2) = (min x1 x2,max x1 x2)
<span class="lineno">  272 </span>--       (my1,my2) = (min y1 y2,max y1 y2)
<span class="lineno">  273 </span>--       (f,c,e) = (floor,ceiling,toEnum)
<span class="lineno">  274 </span>--   in ([((x,e (f my1)),(x,e (c my2))) | x &lt;- [e (c mx1) .. e (f mx2)]]
<span class="lineno">  275 </span>--      ,[((e (f mx1),y),(e (c mx2),y)) | y &lt;- [e (c my1) .. e (f my2)]])
<span class="lineno">  276 </span>
<span class="lineno">  277 </span>-- -- | Filtra as linhas que coincidem com a primeira
<span class="lineno">  278 </span>-- filtraCoincidentes :: Linha -&gt; [Linha] -&gt; ([Linha],[Linha])
<span class="lineno">  279 </span>-- filtraCoincidentes l = partition (\li -&gt; l == li || l == (snd li,fst li))
<span class="lineno">  280 </span>
<span class="lineno">  281 </span>-- filtraPertenceLinha :: Linha -&gt; [Ponto] -&gt; [Ponto]
<span class="lineno">  282 </span>-- filtraPertenceLinha ((x1,y1),(x2,y2))
<span class="lineno">  283 </span>--   = let (mx1,mx2) = (min x1 x2,max x1 x2)
<span class="lineno">  284 </span>--         (my1,my2) = (min y1 y2,max y1 y2)
<span class="lineno">  285 </span>--     in filter (\(x,y) -&gt; x &gt;= mx1 &amp;&amp; x &lt;= mx2 &amp;&amp; y &gt;= my1 &amp;&amp; y &lt;= my2)
<span class="lineno">  286 </span>
<span class="lineno">  287 </span>-- -- | Filtra as linhas que não são pontos
<span class="lineno">  288 </span>-- filtraNaoPontos :: [Linha] -&gt; [Linha]
<span class="lineno">  289 </span>-- filtraNaoPontos = filter (\((x1,y1),(x2,y2)) -&gt; x1 /= x2 || y1 /= y2)
<span class="lineno">  290 </span>
<span class="lineno">  291 </span>{- cartesiano :: (Double,Angulo) -&gt; Ponto
<span class="lineno">  292 </span>cartesiano (raio,ang) = (raio * cos ang,raio * sin ang)
<span class="lineno">  293 </span>
<span class="lineno">  294 </span>-- TODO: it can be simplified. In this project x &gt;= 0 and y &gt;= 0
<span class="lineno">  295 </span>polar :: Ponto -&gt; Polar
<span class="lineno">  296 </span>polar (x,y) = (sqrt ((abs x)^2 + (abs y)^2),ang (x,y))
<span class="lineno">  297 </span>  where ang (x,y)
<span class="lineno">  298 </span>          | x == 0 &amp;&amp; y == 0 = undefined
<span class="lineno">  299 </span>          | x == 0 = if y &gt; 0 then pi / 2 else - (pi / 2)
<span class="lineno">  300 </span>          | x &gt; 0  = atan (y / x)
<span class="lineno">  301 </span>          | y &gt; 0  = atan (y / x) + pi
<span class="lineno">  302 </span>          | y &lt; 0  = atan (y / x) - pi
<span class="lineno">  303 </span>-}
<span class="lineno">  304 </span>
<span class="lineno">  305 </span>-- --------------
<span class="lineno">  306 </span>-- == Funcoes auxiliares
<span class="lineno">  307 </span>-- --------------
<span class="lineno">  308 </span>
<span class="lineno">  309 </span>linhaLava :: Int -&gt; [Peca]
<span class="lineno">  310 </span><span class="decl"><span class="nottickedoff">linhaLava 0 =  []</span>
<span class="lineno">  311 </span><span class="spaces"></span><span class="nottickedoff">linhaLava n = Peca Lava 0 : linhaLava (n - 1)</span></span>
<span class="lineno">  312 </span>
<span class="lineno">  313 </span>mapaLava :: (Int,Int) -&gt; Tabuleiro
<span class="lineno">  314 </span><span class="decl"><span class="nottickedoff">mapaLava (size_x, size_y) = aux size_y</span>
<span class="lineno">  315 </span><span class="spaces">  </span><span class="nottickedoff">where aux 0 = []</span>
<span class="lineno">  316 </span><span class="spaces">        </span><span class="nottickedoff">aux n = linhaLava size_x : aux (n-1)</span></span>
<span class="lineno">  317 </span>
<span class="lineno">  318 </span>getPeca :: Posicao -&gt; Tabuleiro -&gt; Peca
<span class="lineno">  319 </span><span class="decl"><span class="nottickedoff">getPeca (x,y) m = m !! y !! x</span></span>
<span class="lineno">  320 </span>                
<span class="lineno">  321 </span>setPeca :: Posicao -&gt; Peca -&gt; Tabuleiro -&gt; Tabuleiro
<span class="lineno">  322 </span><span class="decl"><span class="nottickedoff">setPeca (x,y) pc m =</span>
<span class="lineno">  323 </span><span class="spaces">  </span><span class="nottickedoff">let (a,b) = splitAt y m</span>
<span class="lineno">  324 </span><span class="spaces">  </span><span class="nottickedoff">in a ++ setX x pc (head b) : tail b</span>
<span class="lineno">  325 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  326 </span><span class="spaces">    </span><span class="nottickedoff">setX :: Int -&gt; Peca -&gt; [Peca] -&gt; [Peca]</span>
<span class="lineno">  327 </span><span class="spaces">    </span><span class="nottickedoff">setX x pc l = let (a,b) = splitAt x l</span>
<span class="lineno">  328 </span><span class="spaces">                  </span><span class="nottickedoff">in a ++ pc : tail b</span></span>
<span class="lineno">  329 </span>
<span class="lineno">  330 </span>isLava :: Peca -&gt; Bool
<span class="lineno">  331 </span><span class="decl"><span class="nottickedoff">isLava (Peca Lava _) = True</span>
<span class="lineno">  332 </span><span class="spaces"></span><span class="nottickedoff">isLava _             = False</span></span>
<span class="lineno">  333 </span>
<span class="lineno">  334 </span>isCurva :: Peca -&gt; Bool
<span class="lineno">  335 </span><span class="decl"><span class="nottickedoff">isCurva (Peca (Curva _) _) = True</span>
<span class="lineno">  336 </span><span class="spaces"></span><span class="nottickedoff">isCurva _                  = False</span></span>
<span class="lineno">  337 </span>
<span class="lineno">  338 </span>altura :: Peca -&gt; Altura
<span class="lineno">  339 </span><span class="decl"><span class="nottickedoff">altura (Peca _ h) = h</span></span>
<span class="lineno">  340 </span>
<span class="lineno">  341 </span>inBounds :: Posicao -&gt; Posicao -&gt; Bool
<span class="lineno">  342 </span><span class="decl"><span class="nottickedoff">inBounds (x,y) (maxx,maxy) = x &gt;= 0 &amp;&amp; x &lt; maxx &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; maxy</span></span>
<span class="lineno">  343 </span>
<span class="lineno">  344 </span>inTabuleiro :: Posicao -&gt; Tabuleiro -&gt; Bool
<span class="lineno">  345 </span><span class="decl"><span class="nottickedoff">inTabuleiro p t = inBounds p (length $ head t,length t)</span></span>
<span class="lineno">  346 </span>
<span class="lineno">  347 </span>linhasMesmoTamanho :: Tabuleiro -&gt; Bool
<span class="lineno">  348 </span><span class="decl"><span class="nottickedoff">linhasMesmoTamanho [] = True</span>
<span class="lineno">  349 </span><span class="spaces"></span><span class="nottickedoff">linhasMesmoTamanho l  =</span>
<span class="lineno">  350 </span><span class="spaces">  </span><span class="nottickedoff">let primeira = length $ head l</span>
<span class="lineno">  351 </span><span class="spaces">      </span><span class="nottickedoff">diff_size = filter (\l -&gt; length l /= primeira) l</span>
<span class="lineno">  352 </span><span class="spaces">  </span><span class="nottickedoff">in null diff_size</span></span>
<span class="lineno">  353 </span>
<span class="lineno">  354 </span>minMax :: Posicao -&gt; (Posicao,Posicao) -&gt; (Posicao, Posicao)
<span class="lineno">  355 </span><span class="decl"><span class="nottickedoff">minMax p (p1,p2) = (pmin p p1, pmax p p2)</span></span>
<span class="lineno">  356 </span>    
<span class="lineno">  357 </span>pmax, pmin :: Posicao -&gt; Posicao -&gt; Posicao
<span class="lineno">  358 </span><span class="decl"><span class="nottickedoff">pmax (x1,y1) (x2,y2) = (max x1 x2, max y1 y2)</span></span>
<span class="lineno">  359 </span><span class="decl"><span class="nottickedoff">pmin (x1,y1) (x2,y2) = (min x1 x2, min y1 y2)</span></span>
<span class="lineno">  360 </span>
<span class="lineno">  361 </span>rodaDir,rodaEsq,inverte :: Orientacao -&gt; Orientacao
<span class="lineno">  362 </span><span class="decl"><span class="nottickedoff">rodaDir Norte = Este</span>
<span class="lineno">  363 </span><span class="spaces"></span><span class="nottickedoff">rodaDir Este  = Sul</span>
<span class="lineno">  364 </span><span class="spaces"></span><span class="nottickedoff">rodaDir Sul   = Oeste</span>
<span class="lineno">  365 </span><span class="spaces"></span><span class="nottickedoff">rodaDir Oeste = Norte</span></span>
<span class="lineno">  366 </span>
<span class="lineno">  367 </span><span class="decl"><span class="nottickedoff">rodaEsq Norte = Oeste</span>
<span class="lineno">  368 </span><span class="spaces"></span><span class="nottickedoff">rodaEsq Oeste = Sul</span>
<span class="lineno">  369 </span><span class="spaces"></span><span class="nottickedoff">rodaEsq Sul   = Este</span>
<span class="lineno">  370 </span><span class="spaces"></span><span class="nottickedoff">rodaEsq Este  = Norte</span></span>
<span class="lineno">  371 </span>
<span class="lineno">  372 </span><span class="decl"><span class="nottickedoff">inverte Norte = Sul</span>
<span class="lineno">  373 </span><span class="spaces"></span><span class="nottickedoff">inverte Sul   = Norte</span>
<span class="lineno">  374 </span><span class="spaces"></span><span class="nottickedoff">inverte Este  = Oeste</span>
<span class="lineno">  375 </span><span class="spaces"></span><span class="nottickedoff">inverte Oeste = Este</span></span>
<span class="lineno">  376 </span>
<span class="lineno">  377 </span>proxPos :: Posicao -&gt; Orientacao -&gt; Posicao
<span class="lineno">  378 </span><span class="decl"><span class="nottickedoff">proxPos (x,y) Norte = (x, y - 1)</span>
<span class="lineno">  379 </span><span class="spaces"></span><span class="nottickedoff">proxPos (x,y) Sul   = (x, y + 1)</span>
<span class="lineno">  380 </span><span class="spaces"></span><span class="nottickedoff">proxPos (x,y) Este  = (x + 1, y)</span>
<span class="lineno">  381 </span><span class="spaces"></span><span class="nottickedoff">proxPos (x,y) Oeste = (x - 1, y)</span></span>
<span class="lineno">  382 </span>
<span class="lineno">  383 </span>pecaCompativel :: Orientacao -&gt; Peca -&gt; Bool
<span class="lineno">  384 </span><span class="decl"><span class="nottickedoff">pecaCompativel _     (Peca Recta _)      = True</span>
<span class="lineno">  385 </span><span class="spaces"></span><span class="nottickedoff">pecaCompativel o (Peca (Rampa op) _)     = o  == op    || o == inverte op</span>
<span class="lineno">  386 </span><span class="spaces"></span><span class="nottickedoff">pecaCompativel Norte (Peca (Curva op) _) = op == Norte || op == Este</span>
<span class="lineno">  387 </span><span class="spaces"></span><span class="nottickedoff">pecaCompativel Sul   (Peca (Curva op) _) = op == Sul   || op == Oeste</span>
<span class="lineno">  388 </span><span class="spaces"></span><span class="nottickedoff">pecaCompativel Este  (Peca (Curva op) _) = op == Este  || op == Sul</span>
<span class="lineno">  389 </span><span class="spaces"></span><span class="nottickedoff">pecaCompativel Oeste (Peca (Curva op) _) = op == Oeste || op == Norte</span>
<span class="lineno">  390 </span><span class="spaces"></span><span class="nottickedoff">pecaCompativel _     _                   = False</span></span>
<span class="lineno">  391 </span>
<span class="lineno">  392 </span>acessoOk :: Orientacao -&gt; Peca -&gt; Altura -&gt; Bool
<span class="lineno">  393 </span><span class="decl"><span class="nottickedoff">acessoOk Norte (Peca (Rampa Sul)   hp) h  = h == (hp+1)</span>
<span class="lineno">  394 </span><span class="spaces"></span><span class="nottickedoff">acessoOk Sul   (Peca (Rampa Norte) hp) h  = h == (hp+1)</span>
<span class="lineno">  395 </span><span class="spaces"></span><span class="nottickedoff">acessoOk Este  (Peca (Rampa Oeste) hp) h  = h == (hp+1)</span>
<span class="lineno">  396 </span><span class="spaces"></span><span class="nottickedoff">acessoOk Oeste (Peca (Rampa Este)  hp) h  = h == (hp+1)</span>
<span class="lineno">  397 </span><span class="spaces"></span><span class="nottickedoff">acessoOk o pc h | pecaCompativel o pc     = h == altura pc</span>
<span class="lineno">  398 </span><span class="spaces"></span><span class="nottickedoff">acessoOk _ _  _                           = False</span></span>
<span class="lineno">  399 </span>
<span class="lineno">  400 </span>proxAlt :: Peca -&gt; Orientacao -&gt; Altura
<span class="lineno">  401 </span><span class="decl"><span class="nottickedoff">proxAlt (Peca (Rampa o1) h) o2 | o1 == o2 = h+1</span>
<span class="lineno">  402 </span><span class="spaces"></span><span class="nottickedoff">proxAlt (Peca _ h)         _              = h</span></span>
<span class="lineno">  403 </span>
<span class="lineno">  404 </span>-- Orientacao da curva, orientavao de entrada, orientacao de saida
<span class="lineno">  405 </span>saidaCurva :: Orientacao -&gt; Orientacao -&gt; Orientacao
<span class="lineno">  406 </span><span class="decl"><span class="nottickedoff">saidaCurva o1 o2 | o1 == o2 = rodaDir o2</span>
<span class="lineno">  407 </span><span class="spaces"></span><span class="nottickedoff">saidaCurva o1 o2            = rodaEsq o2</span></span>
<span class="lineno">  408 </span>
<span class="lineno">  409 </span>proxByPeca :: Peca -&gt; Orientacao -&gt; Posicao -&gt; (Posicao,Orientacao,Altura)
<span class="lineno">  410 </span><span class="decl"><span class="nottickedoff">proxByPeca    (Peca Recta       h) o p = (proxPos p o, o,h)</span>
<span class="lineno">  411 </span><span class="spaces"></span><span class="nottickedoff">proxByPeca pc@(Peca (Rampa _)   h) o p = (proxPos p o, o, proxAlt pc o)</span>
<span class="lineno">  412 </span><span class="spaces"></span><span class="nottickedoff">proxByPeca    (Peca (Curva opc) h) o p =</span>
<span class="lineno">  413 </span><span class="spaces">  </span><span class="nottickedoff">let r = saidaCurva opc o in (proxPos p r,r,h)</span></span>
<span class="lineno">  414 </span>
<span class="lineno">  415 </span>sizeMapa :: Mapa -&gt; Posicao
<span class="lineno">  416 </span><span class="decl"><span class="nottickedoff">sizeMapa (Mapa _ []) = (0,0)</span>
<span class="lineno">  417 </span><span class="spaces"></span><span class="nottickedoff">sizeMapa (Mapa _ m)  = (length $ head m, length m)</span></span>
<span class="lineno">  418 </span>
<span class="lineno">  419 </span>filtraPeca :: Tabuleiro -&gt; (Peca -&gt; Bool) -&gt; [Posicao]
<span class="lineno">  420 </span><span class="decl"><span class="nottickedoff">filtraPeca pcs f = linhas 0 pcs</span>
<span class="lineno">  421 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  422 </span><span class="spaces">    </span><span class="nottickedoff">linhas :: Int -&gt; Tabuleiro -&gt; [Posicao]</span>
<span class="lineno">  423 </span><span class="spaces">    </span><span class="nottickedoff">linhas _ []     = []</span>
<span class="lineno">  424 </span><span class="spaces">    </span><span class="nottickedoff">linhas l (y:ys) = colunas l 0 y ++ linhas (l+1) ys</span>
<span class="lineno">  425 </span><span class="spaces">    </span><span class="nottickedoff">colunas :: Int -&gt; Int -&gt; [Peca] -&gt; [Posicao]</span>
<span class="lineno">  426 </span><span class="spaces">    </span><span class="nottickedoff">colunas _ _ []     = []</span>
<span class="lineno">  427 </span><span class="spaces">    </span><span class="nottickedoff">colunas l c (x:xs) = if f x then (c,l) : colunas l (c+1) xs</span>
<span class="lineno">  428 </span><span class="spaces">                         </span><span class="nottickedoff">else colunas l (c+1) xs</span></span>

</pre>
</body>
</html>
